/******** DO NOT EDIT THIS FILE ********/
#define MUNIT_ENABLE_ASSERT_ALIASES
#include <stdio.h>
#include <math.h>
#include "munit.h"
#include "rft_client_util.h"

static MunitResult test_init_protocol(const MunitParameter params[], void* fixture);

static MunitResult test_init_segment_undef_data(const MunitParameter params[],
    void* fixture);
static MunitResult test_init_segment_undef_ack(const MunitParameter params[],
    void* fixture);
static MunitResult test_init_segment_withvals(const MunitParameter params[],
    void* fixture);
static MunitResult test_init_segment_payonly(const MunitParameter params[],    
    void* fixture);
    
static MunitResult test_set_udp_socket(const MunitParameter params[], 
    void* fixture);
static MunitResult test_set_udp_socket_err(const MunitParameter params[], 
    void* fixture);

static MunitTest tests[] = {
    { "/test_init_protocol", test_init_protocol, NULL, NULL, 
        MUNIT_TEST_OPTION_NONE, NULL },

    { "/test_init_segment_undef_data", test_init_segment_undef_data, NULL, NULL, 
        MUNIT_TEST_OPTION_NONE, NULL },
    { "/test_init_segment_undef_ack", test_init_segment_undef_ack, NULL, NULL, 
        MUNIT_TEST_OPTION_NONE, NULL },
    { "/test_init_segment_withvals", test_init_segment_withvals, NULL, NULL, 
        MUNIT_TEST_OPTION_NONE, NULL },
    { "/test_init_segment_payonly", test_init_segment_payonly, NULL, NULL, 
        MUNIT_TEST_OPTION_NONE, NULL },

    { "/test_set_udp_socket", test_set_udp_socket, NULL, NULL, 
        MUNIT_TEST_OPTION_NONE, NULL },
    { "/test_set_udp_socket_err", test_set_udp_socket_err, NULL, NULL, 
        MUNIT_TEST_OPTION_NONE, NULL },
        
    { NULL, NULL, NULL, NULL, MUNIT_TEST_OPTION_NONE, NULL},
};

static const MunitSuite suite = {
    "/test_rft_client_util", tests, NULL, 1, MUNIT_SUITE_OPTION_NONE 
};    


int main(int argc, char** argv) {
    return munit_suite_main(&suite, NULL, argc, argv);
}

static void set_segment_values(segment_t* seg, seg_type type, int i) {
    seg->type = type;
    seg->sq = i;
    seg->checksum = i * i;
    seg->file_data =  i * i * i;

    for (int j = 0; j < PAYLOAD_SIZE; j++)
        seg->payload[j] = i + j;
}

static bool verify_segment_values(segment_t* seg, seg_type type, int i) {
    return seg->type == type && seg->sq == i && seg->checksum == i * i 
            && seg->file_data == i * i * i; 
}

static bool segment_is_init(segment_t* seg, seg_type type) {
    bool is_init = true;
    
    for (int i = 0; i < PAYLOAD_SIZE; i++)
        is_init = is_init && !seg->payload[i];
    
    return  is_init && !seg->sq && seg->type == type
                && !seg->checksum && !seg->file_data;
}

static MunitResult test_init_protocol(const MunitParameter params[], 
    void* fixture) {
    protocol_t proto;
    
    init_protocol(&proto);
    
    assert_int(proto.state, ==, PS_INIT);
    assert_null(proto.err_msg);
    assert_null(proto.src_file);
    assert_int(proto.src_line, ==, 0);
    
    for (int i = 0; i < MAX_FILENAME_SIZE; i++) {
        assert_int(proto.in_fname[i], ==, 0);
        assert_int(proto.out_fname[i], ==, 0);
        assert_int(proto.server_addr[i], ==, 0);
    }
    
    assert_int(proto.server_port, ==, 0);
    assert_int(proto.timeout_sec, ==, DEFAULT_TIMEOUT);
    assert_null(proto.in_file);
    assert_llong((long long) proto.fsize, ==, 0);
    assert_int(proto.sockfd, ==, -1);
    
    char* server_ptr = (char*) &proto.server;
    for (int i = 0; i < sizeof(struct sockaddr_in); i++)
        assert_char(server_ptr[i], ==, 0);
    
    assert_llong((long long) proto.seg_size, ==, sizeof(segment_t));
    assert_llong((long long) proto.sockaddr_size, ==, 
        sizeof(struct sockaddr_in));
    
    munit_logf(MUNIT_LOG_INFO, "%s", "verifying proto.data ...");
    assert_true(segment_is_init(&proto.data, DATA_SEG));
    munit_logf(MUNIT_LOG_INFO, "%s", "... proto.data verified");

    munit_logf(MUNIT_LOG_INFO, "%s", "verifying proto.ack ...");
    assert_true(segment_is_init(&proto.ack, ACK_SEG));
    munit_logf(MUNIT_LOG_INFO, "%s", "... proto.ack verified");

    assert_null(proto.tfr_mode);
    assert_null(proto.send_file_op);
    assert_float(proto.loss_prob, ==, 0.0);
    assert_true(fpclassify(proto.loss_prob) == FP_ZERO);
    assert_llong((long long) proto.tfr_bytes, == ,0);
    assert_llong((long long) proto.total_file_data, ==, 0);
    assert_int(proto.total_segments, ==, 0);
    assert_int(proto.resent_segments, ==, 0);
    
    return MUNIT_OK;
}

static MunitResult test_init_segment_undef_data(const MunitParameter params[], 
    void* fixture) {
    protocol_t proto;
    proto.seg_size = sizeof(segment_t);

    proto.ack.sq = 1;
    init_segment(&proto, DATA_SEG, false);
    munit_logf(MUNIT_LOG_INFO, "%s", "verifying proto.data ...");
    assert_true(segment_is_init(&proto.data, DATA_SEG));
    munit_logf(MUNIT_LOG_INFO, "%s", "... proto.data verified");
    munit_logf(MUNIT_LOG_INFO, "%s", "verifying proto.ack ...");
    assert_false(segment_is_init(&proto.ack, ACK_SEG));
    munit_logf(MUNIT_LOG_INFO, "%s", "... proto.ack verified");

    return MUNIT_OK;
}

static MunitResult test_init_segment_undef_ack(const MunitParameter params[], 
    void* fixture) {
    protocol_t proto;
    proto.seg_size = sizeof(segment_t);

    proto.data.sq = 1;
    init_segment(&proto, ACK_SEG, false);
    munit_logf(MUNIT_LOG_INFO, "%s", "verifying proto.ack ...");
    assert_true(segment_is_init(&proto.ack, ACK_SEG));
    munit_logf(MUNIT_LOG_INFO, "%s", "... proto.ack verified");
    munit_logf(MUNIT_LOG_INFO, "%s", "verifying proto.data ...");
    assert_false(segment_is_init(&proto.data, DATA_SEG));
    munit_logf(MUNIT_LOG_INFO, "%s", "... proto.data verified");

    return MUNIT_OK;
}

static MunitResult test_init_segment_withvals(const MunitParameter params[],    
    void* fixture) {
    protocol_t proto;
    proto.seg_size = sizeof(segment_t);

    for (int i = 0; i < 10; i++) {
        set_segment_values(&proto.data, DATA_SEG, i);
        set_segment_values(&proto.ack, ACK_SEG, i);  
              
        assert_true(verify_segment_values(&proto.data, DATA_SEG, i));
        assert_true(verify_segment_values(&proto.ack, ACK_SEG, i));
        for (int j = 0; j < PAYLOAD_SIZE; j++) {
            assert_int(proto.data.payload[j], ==, i + j);
            assert_int(proto.ack.payload[j], ==, i + j);
        }
        
        init_segment(&proto, DATA_SEG, false);

        munit_logf(MUNIT_LOG_INFO, "%s", "verifying proto.data ...");
        assert_true(segment_is_init(&proto.data, DATA_SEG));
        munit_logf(MUNIT_LOG_INFO, "%s", "... proto.data verified");

        munit_logf(MUNIT_LOG_INFO, "%s", "verifying proto.ack ...");
        assert_false(segment_is_init(&proto.ack, ACK_SEG));
        assert_true(verify_segment_values(&proto.ack, ACK_SEG, i));
        for (int j = 0; j < PAYLOAD_SIZE; j++) {
            assert_int(proto.ack.payload[j], ==, i + j);
        }
        munit_logf(MUNIT_LOG_INFO, "%s", "... proto.ack verified");
    }

    for (int i = 0; i < 10; i++) {
        set_segment_values(&proto.data, DATA_SEG, i + 1);
        set_segment_values(&proto.ack, ACK_SEG, i + 1);  
              
        assert_true(verify_segment_values(&proto.data, DATA_SEG, i + 1));
        assert_true(verify_segment_values(&proto.ack, ACK_SEG, i + 1));
        for (int j = 0; j < PAYLOAD_SIZE; j++) {
            assert_int(proto.data.payload[j], ==, i + 1 + j);
            assert_int(proto.ack.payload[j], ==, i + 1 + j);
        }
        
        init_segment(&proto, ACK_SEG, false);

        munit_logf(MUNIT_LOG_INFO, "%s", "verifying proto.ack ...");
        assert_true(segment_is_init(&proto.ack, ACK_SEG));
        munit_logf(MUNIT_LOG_INFO, "%s", "... proto.ack verified");

        munit_logf(MUNIT_LOG_INFO, "%s", "verifying proto.data ...");
        assert_false(segment_is_init(&proto.data, DATA_SEG));
        assert_true(verify_segment_values(&proto.data, DATA_SEG, i + 1));
        for (int j = 0; j < PAYLOAD_SIZE; j++) {
            assert_int(proto.data.payload[j], ==, i + 1 + j);
        }
        munit_logf(MUNIT_LOG_INFO, "%s", "... proto.data verified");
    }

    return MUNIT_OK;
}
    
static MunitResult test_init_segment_payonly(const MunitParameter params[], 
    void* fixture) {
    protocol_t proto;
    proto.seg_size = sizeof(segment_t);

    for (int i = 0; i < 10; i++) {
        set_segment_values(&proto.data, DATA_SEG, i);        
        set_segment_values(&proto.ack, ACK_SEG, i);        
        assert_true(verify_segment_values(&proto.data, DATA_SEG, i));
        assert_true(verify_segment_values(&proto.ack, ACK_SEG, i));
        for (int j = 0; j < PAYLOAD_SIZE; j++) {
            assert_int(proto.data.payload[j], ==, i + j);
            assert_int(proto.ack.payload[j], ==, i + j);
        }
        
        init_segment(&proto, DATA_SEG, true);
        
        assert_true(verify_segment_values(&proto.data, DATA_SEG, i));
        assert_true(verify_segment_values(&proto.ack, ACK_SEG, i));
        for (int j = 0; j < PAYLOAD_SIZE; j++) {
            assert_int(proto.data.payload[j], ==, 0);
            assert_int(proto.ack.payload[j], ==, i + j);
        }
    }
        
    for (int i = 0; i < 10; i++) {
        set_segment_values(&proto.data, DATA_SEG, i + 1);        
        set_segment_values(&proto.ack, ACK_SEG, i + 1);        
        assert_true(verify_segment_values(&proto.data, DATA_SEG, i + 1));
        assert_true(verify_segment_values(&proto.ack, ACK_SEG, i + 1));
        for (int j = 0; j < PAYLOAD_SIZE; j++) {
            assert_int(proto.data.payload[j], ==, i + 1 + j);
            assert_int(proto.ack.payload[j], ==, i + 1 + j);
        }
        
        init_segment(&proto, ACK_SEG, true);
        
        assert_true(verify_segment_values(&proto.data, DATA_SEG, i + 1));
        assert_true(verify_segment_values(&proto.ack, ACK_SEG, i + 1));
        for (int j = 0; j < PAYLOAD_SIZE; j++) {
            assert_int(proto.data.payload[j], ==, i + 1 + j);
            assert_int(proto.ack.payload[j], ==, 0);
        }
    }
    
    return MUNIT_OK;
}

static MunitResult test_set_udp_socket(const MunitParameter params[], 
    void* fixture) {
    char* server_addr;
    protocol_t proto;
    
    proto.state = PS_INIT;
    proto.sockfd = -1;
    server_addr = "127.0.0.1";
    
    snprintf(proto.server_addr, MAX_FILENAME_SIZE, "%s", server_addr);
    assert_string_equal(proto.server_addr, server_addr);
        
    set_udp_socket(&proto);
    
    assert_int(proto.state, ==, PS_TFR_READY);
    assert_int(proto.sockfd, !=, -1);
    close(proto.sockfd);

    proto.state = PS_INIT;
    proto.sockfd = -1;
    server_addr = "128.240.212.56";
    
    snprintf(proto.server_addr, MAX_FILENAME_SIZE, "%s", server_addr);
    assert_string_equal(proto.server_addr, server_addr);
        
    set_udp_socket(&proto);
    
    assert_int(proto.state, ==, PS_TFR_READY);
    assert_int(proto.sockfd, !=, -1);
    close(proto.sockfd);
 
    proto.state = PS_INIT;
    proto.sockfd = -1;
    server_addr = "128";
    
    snprintf(proto.server_addr, MAX_FILENAME_SIZE, "%s", server_addr);
    assert_string_equal(proto.server_addr, server_addr);
        
    set_udp_socket(&proto);
    
    assert_int(proto.state, ==, PS_TFR_READY);
    assert_int(proto.sockfd, !=, -1);
    close(proto.sockfd);

    return MUNIT_OK;
}

static  MunitResult test_set_udp_socket_err(const MunitParameter params[], 
    void* fixture) {
    char* server_addr;
    protocol_t proto;
    
    proto.state = PS_INIT;
    proto.sockfd = -1;
    memset(proto.server_addr, 0, MAX_FILENAME_SIZE);
        
    set_udp_socket(&proto);
    
    assert_int(proto.state, ==, PS_INIT);
    assert_int(proto.sockfd, ==, -1);
    
    server_addr = "cs-linux.ncl.ac.uk";
    snprintf(proto.server_addr, MAX_FILENAME_SIZE, "%s", server_addr);
    assert_string_equal(proto.server_addr, server_addr);
    set_udp_socket(&proto);
    
    assert_int(proto.state, ==, PS_INIT);
    assert_int(proto.sockfd, ==, -1);

    server_addr = "invalid_addr";
    snprintf(proto.server_addr, MAX_FILENAME_SIZE, "%s", server_addr);
    assert_string_equal(proto.server_addr, server_addr);
    set_udp_socket(&proto);
    
    assert_int(proto.state, ==, PS_INIT);
    assert_int(proto.sockfd, ==, -1);

    return MUNIT_OK;
}

