/******** DO NOT EDIT THIS FILE ********/
#include <fcntl.h>
#include <stdlib.h>
#include <time.h>
#include <sys/stat.h>
#include <errno.h>
#include <string.h>
#include <math.h>
#include "rft_client_logging.h"

/*
 * This file contains the main function for the client.
 * Do NOT change anything in this file.
 * 
 * For a usage message for the client type:
 * 
 *      rft_client
 *    
 * this will output a message explaining the command line options.
 *
 * Or start client as:
 *
 *      rft_client <input_file> <output_file> <server_addr> <port> 
 *                  <nm|wt loss_probability>  
 *
 * Where:
 *      input_file is the file to send
 *      output_file is name for the file on the server
 *      server_addr is the address of the server
 *      port is the port the server is listening on
 *      nm selects normal transfer mode
 *      wt selects transfer with time out and a probability of loss or 
 *          corruption of segments. The probability must be between 0.0 and 1.0,
 *          inclusive.
 *
 * Only specify one transfer mode. That is, either nm or wt with a loss 
 * probability.      
 */

/* helper functions to process command line arguments and report errors */
static void process_argv(protocol_t* proto, int argc, char** argv);

/* the main function and entry point for rft_client */
int main(int argc,char *argv[]) {
    if (argc < 6) {
        printf("usage: %s <input_file> <output_file> <server_addr> <port>"
            " <nm|wt loss_probability>\n", argv[0]);
        printf("       input_file is the file to send\n");
        printf("       output_file is name for the file on the server\n");
        printf("       server_addr is the address of the server\n");
        printf("       port is the port the server is listening on\n");
        printf("       nm selects normal transfer, or:\n");
        printf("       wt selects transfer with time out \n");
        printf("          and a probability of loss between 0.0 and 1.0\n");
        exit(EXIT_FAILURE);
    }

    srand((unsigned) time(NULL));    // seed PRNG for is_corrupted function
    
    protocol_t proto;
    init_protocol(&proto);

    proto.src_file = __FILE__;
    
    process_argv(&proto, argc, argv);
    
    proto.src_line = __LINE__;
    log_protocol(&proto);
      
    struct stat sbuf;
    int r = stat(proto.in_fname, &sbuf);
    if (r < 0)
        exit_err_msg(&proto, errno, __LINE__, "Could not stat input file");
    
    proto.fsize = sbuf.st_size;
    proto.tfr_bytes = (size_t) proto.fsize;
    

    /* try opening input file */
    proto.in_file = fopen(proto.in_fname, "r");
    
    if (!proto.in_file)
        exit_err_msg(&proto, errno, __LINE__, "Could not open input file");
        
    /* set UDP socket and server information */
    set_udp_socket(&proto);
    
    if (!proto.state)
        exit_err_msg(&proto, EINVAL, __LINE__, 
            "Could not set socket or proto.server_addr is invalid");
    
    proto.src_line = __LINE__;
    log_protocol(&proto);

    /* Send meta data to the server */
    if (!send_metadata(&proto))
        exit_err_msg(&proto, errno, __LINE__, "Sending metadata failed");
    
    proto.send_file_op(&proto);
    
    proto.src_file = __FILE__;
    proto.src_line = __LINE__;
    log_protocol(&proto);
    
    print_sep();
    
    fclose(proto.in_file);
    
    close(proto.sockfd);
    
    exit(EXIT_SUCCESS);
} 

static void process_argv(protocol_t* proto, int argc, char** argv) {
    if (strnlen(argv[1], MAX_FILENAME_SIZE) > MAX_FILENAME_SIZE - 1)
        exit_err_msg(proto, EINVAL, __LINE__, 
            "Input file name is longer than max length");
    
    snprintf(proto->in_fname, MAX_FILENAME_SIZE, "%s", argv[1]);
    
    if (strnlen(argv[2], MAX_FILENAME_SIZE) > MAX_FILENAME_SIZE - 1)
        exit_err_msg(proto, EINVAL, __LINE__, 
            "Output file name is longer than max length");

    snprintf(proto->out_fname, MAX_FILENAME_SIZE, "%s", argv[2]);

    if (strnlen(argv[3], MAX_FILENAME_SIZE) > MAX_FILENAME_SIZE - 1)
        exit_err_msg(proto, EINVAL, __LINE__, 
            "Server address is longer than max length");

    snprintf(proto->server_addr, MAX_FILENAME_SIZE, "%s", argv[3]);

    proto->server_port = atoi(argv[4]);
    if (proto->server_port < PORT_MIN || proto->server_port > PORT_MAX)
        exit_err_msg(proto, EINVAL, __LINE__, "Port is outside valid range");

    proto->tfr_mode = argv[5];
    
    if (argc == 6 && !strncmp(argv[5], NORMAL_TFR_MODE, TFR_MODE_SIZE))
        proto->send_file_op = send_file_normal;
    
    if (argc == 7 && !strncmp(argv[5], TIMEOUT_TFR_MODE, TFR_MODE_SIZE)) {
        proto->send_file_op = send_file_with_timeout;
        proto->loss_prob = atof(argv[6]);

        if (signbit(proto->loss_prob) || isgreater(proto->loss_prob, 1.0))
            exit_err_msg(proto, EINVAL, __LINE__, 
                "Loss probability is outside valid range");
    }
    
    if (!proto->send_file_op)
        exit_err_msg(proto, EINVAL, __LINE__, "Invalid transfer mode");  
}


