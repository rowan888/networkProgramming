/******** DO NOT EDIT THIS FILE ********/
#ifndef _RFT_CLIENT_H
#define _RFT_CLIENT_H
#include <stdio.h>
#include "rft_util.h"

/*
 * INTRODUCTION AND WHAT YOU HAVE TO DO
 * For this assignment, you have to implement the following functions declared
 * and documented in this file:
 *      init_segment
 *      read_data
 *      send_data
 *      send_file_with_timeout
 *      send_metadata
 *      set_socket_timeout
 *      set_udp_socket
 *
 * You implement the functions in rft_client_util.c.
 *
 * Do not change any function signatures and do not change any other functions
 * or code provided.
 *
 * That is, you do not edit this file. You edit the functions listed above
 * in rft_client_util.c
 */

#define TFR_MODE_SIZE 3         // size of transfer mode command string
#define NORMAL_TFR_MODE "nm"    // normal transfer mode:
                                //      selects send_file_normal
#define TIMEOUT_TFR_MODE "wt"   // timeout transfer mode:
                                //      selects send_file_with_timeout
#define DEFAULT_TIMEOUT 2       // default timeout in seconds
#define DEFAULT_RETRIES 20      // default number of consecutive retries 
                                // before exiting

/* 
 * proto_state enum to determine which log messages are selected during 
 * protocol execution.
 * 
 * Assigning one of these states to the state field of a protocol structure
 * will select the corresponding logging statement when the log_protocol
 * function defined in rft_client_logging.h is called.
 *
 * The protocol state can also be used to control execution of a protocol. 
 * For example, to determine whether it is necessary to resend a data segment
 * after an ACK timeout.
 *
 * Note, the enum values have been carefully selected - only PS_DATA_RESEND
 * and PS_NO_ACK have odd values (1 and 3 respectively). These are the only
 * states that have their 1 bit set. That is, PS_DATA_RESEND and PS_NO_ACK
 * are the only states for which PS_DATA_RESEND & proto.state is true. This is
 * deliberate.
 *
 * & in the above is the bitwise operator (not the && logical operator). 
 * 
 * x & 1 is true if and only if the 2^0 bit of x is 1
 * 
 * For example:
 * if x is 2 (which means the lower byte is 0000 0010 - with the 2^1 bit set to
 * 1):
 *      x & 1 evaluates to:
 *            0000 0010 
 *          & 0000 0001
 *          = 0000 0000
 *          = 0 or false
 *
 * if x is 5 (which means the lower byte is 0000 0101 - with the 2^0 bit set
 * to 1 and the 2^2 bit set to 1):
 *      x & 1 evaluates to:
 *            0000 0101 
 *          & 0000 0001
 *          = 0000 0001
 *          = 1 or true
 *
 * See also: rft_client_logging.h and rft_client_logging.h to understand 
 * how logging and error exit works.
 */
typedef enum {
    PS_INIT         = 0,    // initial state
    PS_DATA_RESEND  = 1,    // resending data to the server
    PS_TFR_READY    = 2,    // ready for transfer - set after socket opened
    PS_NO_ACK       = 3,    // no ACK received from the server
    PS_START_SEND   = 4,    // start sending file (in a send file function)
    PS_DATA_SEND    = 6,    // sending data (not resending)
    PS_ACK_WAIT     = 8,    // waiting for an ACK from the server
    PS_ACK_RECV     = 10,   // ACK received from the server
    PS_TFR_COMPLETE = 12,   // transfer completed
    PS_EMPTY_FILE   = 14,   // empty input file detected (size: 0 bytes)
    PS_BAD_READ     = 16,   // file read error
    PS_BAD_SEND     = 18,   // send error
    PS_BAD_ACK      = 20,   // bad ACK from server
    PS_BAD_ACK_SQ   = 22,   // ACK seq. number does not match data seq. number
    PS_BAD_S_SIZE   = 24,   // bad server address struct size in ACK
    PS_BAD_S_FAM    = 26,   // bad sin_family in server ACK
    PS_BAD_S_PORT   = 28,   // bad sin_port in server ACK
    PS_BAD_S_ADDR   = 30,   // bad sin_addr in server ACK
    PS_EXCEED_RETRY = 32,   // retry limit exceeded
    PS_BAD_SOCKTOUT = 34,   // could not set the socket timeout option
    PS_BAD_LOG      = 36    // protocol source file name or line number not set
                            // for logging
} proto_state;

/*
 * protocol struct - alias protocol_t. 
 * The protocol structure provides the fields listed below to 
 * control the execution of a transfer protocol and provide access to the 
 * resources needed for a file transfer (such as the file to transfer, 
 * the open socket etc.)
 * 
 * proto_state state - the current state of the protocol (see prot_state enum)
 * 
 * char* err_msg - an error message string to use for error reporting 
 *      when protocol state is < PS_BAD_READ. The err_msg is typically only
 *      set for the PS_INIT state.
 * 
 * char* src_file - the current source code file the protocol is executing 
 *      from for debugging purposes (should be set to __FILE__)
 * 
 * int src_line - the current line number in the source code file the protocol
 *      is executing from for debugging/logging purposes (should be set to 
 *      __LINE__ before calling a log function)
 * 
 * char in_fname[MAX_FILENAME_SIZE] - the name of the client-side input file 
 *      for transfer to the server
 * 
 * char out_fname[MAX_FILENAME_SIZE] - the name of the output file to create on
 *      the server as a result of the file transfer
 * 
 * off_t fsize - the size of the client-side input file (set when the file 
 *      status is determined before opening)
 * 
 * char server_addr[MAX_FILENAME_SIZE] - the address of the server to transfer
 *      the file to. This should be a well-formed IP address.
 * 
 * uint16_t server_port - the 16 bit port the server is listening on
 * 
 * FILE* in_file - a pointer to the open client-side input file to transfer
 *      (NULL if not open, set when the file is open)
 * 
 * int sockfd - the socket to communicate with the server (-1 if not open, 
 *      set by set_udp_socket)
 * 
 * struct sockaddr_in server - the address structure of the server to
 *      communicate with (set by set_udp_socket)
 * 
 * socklen_t sockaddr_size - the size of a sockaddr_in struct
 * 
 * segment_t data - the protocol data segment for sending segments with 
 *      payload read from the input file to the server 
 * 
 * segment_t ack - the protocol ack segment for receiving ACKs from the server
 * 
 * size_t seg_size - the size of a segment_t struct
 * 
 * char* tfr_mode - the protocol tfr mode (NORMAL_TFR_MODE or TIMEOUT_TFR_MODE)
 * 
 * void (*send_file_op)(protocol_t*) - a pointer to the function to use to
 *      send a file to the server. This will be set to either 
 *      send_file_normal or send_file_with_timeout
 * 
 * size_t tfr_bytes - the number of bytes remaining to be transferred during
 *      execution of a transfer. This is set to fsize (input file size) when 
 *      the input file status is obtained
 *
 * float loss_prob - the probability of loss or corruption of a data 
 *      transfer segment during the send_file_with_timeout protocol
 * 
 * time_t timeout_sec - the timeout in seconds to use for the protocol 
 *      with timeout (used to set the socket timeout property)
 * 
 * int curr_retry - the current number of consecutive retries 
 *      (retransmissions) following message loss or corruption
 *
 * int max_retries - the maximum number of consecutive retries 
 *      (retransmissions) to allow before exiting the client
 *
 * size_t total_file_data - the accumulated total file data transferred to the
 *      server as the result of a file transfer
 *
 * int total_segments - the accumulated total number of data segments
 *      transferred to the server as the result of a file transfer
 *
 * int resent_segments - the accumulated total number of data segments resent
 *      to the server as a result of timeouts during a file transfer
 *
 * See also: rft_client_logging.h
 */
typedef struct protocol protocol_t;
struct protocol {
    proto_state state;
    char* err_msg;
    char* src_file;
    int src_line;
    char in_fname[MAX_FILENAME_SIZE];
    char out_fname[MAX_FILENAME_SIZE];
    off_t fsize;
    char server_addr[MAX_FILENAME_SIZE];
    uint16_t server_port;
    FILE* in_file;
    int sockfd;
    struct sockaddr_in server;
    socklen_t sockaddr_size;
    segment_t data;
    segment_t ack;
    size_t seg_size;
    char* tfr_mode;
    void (*send_file_op)(protocol_t*);
    size_t tfr_bytes;
    float loss_prob;
    time_t timeout_sec;
    int curr_retry;
    int max_retries;
    size_t total_file_data;
    int total_segments;
    int resent_segments;
};

/* 
 * init_protocol(protocol_t* proto) - initialises the protocol structure
 *
 * Documentation of this function is deliberately omitted - see the 
 * implementation in rft_client_util.c
 */
void init_protocol(protocol_t* proto);

/* 
 * init_segment(protocol_t* proto, seg_type type, bool payload_only)
 *      - initialises the segment identified by the given type.
 *
 *      If payload_only is false, the whole segment (data or ack as determined
 *      by the type parameter) is initialised as follows:
 *      - all bytes (and therefore fields) of the segment are zeroed
 *      - the segment type is set to the given type
 *
 *      If payload_only is true, the payload buffer of the segment identified
 *      by the given type is zeroed. No other field of the segment is affected.
 *
 * Parameters:
 * proto - a non-null pointer to a protocol structure. If proto is NULL, the
 *      client will terminate with a fatal memory error. If proto is not NULL, 
 *      the relevant segment of the given protocol structure is initialised.
 * type - the segment type to initialise (either the DATA_SEG or the ACK_SEG).
 * payload_only - a flag to only initialise the segment's payload buffer if
 *      payload_only is true and to initialise the whole segment if payload_only
 *      is false
 *
 * Return:
 * The function does not have a return value. Instead, the identified segment
 * of the given protocol structure is initialised as described above.
 */
void init_segment(protocol_t* proto, seg_type type, bool payload_only);

/* 
 * read_data(protocol_t* proto) - read the next chunk of data from the 
 *      given proto's in_file into the proto's data segment payload buffer.
 *
 * On success the given proto structure is updated as follows:
 *  - file data is read the proto's file to the proto's data payload buffer
 *  - data segment's file_data field is set to the number of bytes read 
 *      from the file
 *  - the tfr_bytes of the proto structure is updated so that it records 
 *      the remaining bytes to be read from the file after this segment is
 *      transferred. When all file bytes have been read, tfr bytes will be
 *      zero
 *      
 * read_data must ensure that the data segment's payload buffer is filled
 * with trailing zeroes after the data read from file. This ensures
 * that the server can treat the data it receives as a valid string.
 * 
 * Parameters:
 * proto - a non-null pointer to a protocol structure. If proto is NULL, the
 *  client will terminate with a fatal memory error.
 *
 * Return:
 * The function does not have a return value. Instead, the fields of the 
 * protocol structure are updated as noted above.
 *
 * Errors:
 * If there are errors on read, the read_data function exits the client with 
 * an appropriate error state.
 *
 * See also: man pages for fread and ferror
 */
void read_data(protocol_t* proto);

/* 
 * send_data(protocol_t* proto) - send the given proto's data segment to 
 *      the server, as a side effect the function outputs a log message.
 *
 * send_data computes a checksum of the data and sets the data segments's
 * checksum prior to sending. If the transfer mode is with timeout (wt), 
 * the checksum should be corrupted with the loss probability specified 
 * by the proto structure.
 *
 * After computing the checksum and before sending the data segment, 
 * send_data outputs a log of protocol information.
 * 
 * Parameters:
 * proto - a non-null pointer to a protocol structure that has sockfd and 
 *      server fields. If proto is NULL, the client will terminate with a 
 *      fatal memory error.
 *
 * Return:
 * The function does not have a return value.
 *
 * Errors:
 * If the count of consecutive retries/retransmissions exceeds the maximum
 * number of allowed retries, the send_data function exits the client with an
 * appropriate error state.
 *
 * If the there is an error sending the data segment (for example, the bytes
 * sent is not the expected segment size), the send_data function exits the
 * client with an appropriate error state.
 */
void send_data(protocol_t* proto);

/* 
 * send_file_normal(protocol_t* proto) - transfer the given protocol
 *      structure's file using the resources provided by the protocol
 *      structure, according to the normal file transfer without timeout
 *      or retransmission.
 *
 * Documentation of this function is deliberately omitted - see the 
 * implementation in rft_client_util.c
 */
void send_file_normal(protocol_t* proto);

/* 
 * send_file_with_timeout(protocol_t* proto) - transfer the given protocol
 *      structure's file using the resources provided by the protocol
 *      structure.
 *
 * This function is similar to the send_file_normal function except that it
 * resends data segments if no ACK for a segment is received from the server. 
 * To implement this, the function:
 *  - simulates network corruption or loss of data segments by
 *      injecting corruption into segment checksums. The checksum is computed
 *      in send_data.
 *  - times-out when waiting to receive an ACK from the server
 *      for a data segment. The server does not ACK corrupted segments.
 *      Therefore, this client function will timeout waiting for an ACK 
 *      for a corrupted segment. When the timeout expires, the 
 *      function resends the data segment. The timeout is set in 
 *      set_socket_timeout. 
 *
 * The file is sent in chunks as the payload of a succession of one or 
 * more data segments until the whole file has been transferred. The read_data
 * function reads from the file in payload size chunks. The send_data function
 * sends the segments.
 *
 * The server expects each chunk of a file to be a correctly terminated
 * string.
 *
 * Data and ACK messages are sent as segment_t structs defined in rft_util.h
 *
 * This function has the following side effects:
 *  - output of information messages for the user to follow progress of the
 *      file transfer.
 *  - exit of the client on detection of an error in the file transfer 
 *      process. Errors may arise from reading the file on the client 
 *      side or from sending the file to the server or from receiving 
 *      ACKS from the server (that is, actual errors in receipt of ACKS as
 *      opposed to timeout of ACKS)
 *
 * During execution of this function, the protocol goes through the same
 * states as for send_file_normal with the following exception:
 *  - non-receipt of an ACK leads to the PS_NO_ACK state, which should be 
 *      logged, and then the PS_DATA_RESEND state after logging.
 *
 * In addition to updating the proto state field, this function updates fields
 * to that record the progress of a file transfer. This includes the 
 * number of consecutive retries.
 *
 * Functions of the rft_client_logging library are used for output. Also
 * see the setnlog_protocol helper function in rft_client_util.c.
 * 
 * The set
 *
 * Parameters:
 * proto - a non-null pointer to a protocol structure that has all 
 *      the information required for the file transfer. If proto is
 *      NULL, the client will terminate with a fatal memory error.
 * 
 * Return:
 * The function does not have a return value. Instead, the fields of the 
 * protocol structure are updated.
 *
 * On success: the function returns after completing the file transfer
 *      with the following fields of the protocol structure updated:
 *      - total segments transferred
 *      - number of segments resent due to ACK timeouts
 *      - total payload transferred 
 * Other fields of the structure are also updated during progress of the 
 * a transfer.
 *
 * On failure: the function causes the client to exit with an appropriate error
 * state.
 *
 * Relevant functions/libraries include: rft_client_logging library,
 *  set_socket_timeout, read_data, send_data, recvfrom system library function.
 */
void send_file_with_timeout(protocol_t* proto);

/* 
 * send_metadata(protocol_t* proto) - send protocol metadata to the server.
 *
 * Sending metadata starts a transfer by sending the following information to
 * the server in the metadata_t struct (defined in rft_util.h):
 *      size - the size of the file to send in bytes
 *      name - the name of the file to create on the server
 *  
 * This function does not have any side effects. It does not log any output, 
 * does not exit the client in event of an error and does not set any of the
 * fields of the proto struct.
 *
 * Parameters:
 * proto - a non-null pointer to a protocol structure that has all 
 *      the information required to send metadata from client to server. 
 *      If proto is NULL, the client will terminate with a fatal memory error.
 *
 * Return:
 * True if the metadata was successfully sent, false otherwise.
 */
bool send_metadata(protocol_t* proto);
    
/* 
 * set_socket_timeout(protocol_t* proto) - set the socket timeout for receiving
 *      and ACK to the timeout_sec field of the given proto.
 *
 * A timeout is a socket level option that can be set for sending and/or 
 * receiving on a socket. See setsockopt man page or:
 * https://man7.org/linux/man-pages/man3/setsockopt.3p.html and related 
 * pages.
 *
 *
 * Parameters:
 * proto - a non-null pointer to a protocol structure. If proto is NULL, the
 *      client will terminate with a fatal memory error.
 *
 * Return:
 * The function does not have a return value.
 *
 * On success: the function sets the timeout property of the proto structures
 * socket
 * 
 * On failure: the function causes the client to exit with an appropriate error
 * state. 
 */
void set_socket_timeout(protocol_t* proto);

/* 
 * set_udp_socket(protocol_t* proto) - opens a UDP socket to communicate with
 *      the server and sets the sockfd field of the given protocol structure 
 *      to the open socket. If opening the socket succeeds, this function also
 *      updates the protocol structure as follows:
 *      - sin_family, sin_addr.s_addr and sin_port fields of the structure's
 *          server sockaddr_in struct are set as appropriate for communication
 *          with the server specified by the protocol structure's server_addr
 *          and server_port
 *      - state field is set to PS_TFR_READY
 *
 * This function does not log any output, and does not exit the client in event
 * of an error.
 *
 * Parameters:
 * proto - a non-null pointer to a protocol structure. If proto is NULL, 
 *      the client will terminate with a fatal memory error.
 *
 * Return:
 * The function does not have a return value. Instead, the fields of the 
 * protocol structure are updated.
 *
 * On success: the function sets both the sockfd and server fields of the 
 *      protocol structure to valid values, and the state field is set to 
 *      PS_TFR_READY.
 * 
 * Errors:
 * If opening the socket fails, the sockfd field of the protocol structure 
 * will be set to -1, the server field will not be updated and the 
 * state field will not be updated.
 *
 * If setting the server fields results in invalid configuration (e.g. the
 * server_addr is invalid), then this function closes the socket (if it has
 * been opened) and sets the sockfd field to -1 and the state field will not be
 * updated (not set to PS_TFR_READY).
 *
 * See also: man pages for socket, htons and inet_aton
 */
void set_udp_socket(protocol_t* proto);

#endif


