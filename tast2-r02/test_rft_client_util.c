/******** DO NOT EDIT THIS FILE ********/
#define MUNIT_ENABLE_ASSERT_ALIASES
#include <stdio.h>
#include <math.h>
#include <arpa/inet.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/wait.h>

#include "munit.h"
#include "rft_client_util.h"

#define TEST_PORT 20333
#define TEST_PORT_ERR_LINE 13

static MunitResult test_init_protocol(const MunitParameter params[], void* fixture);

static MunitResult test_init_segment_undef_data(const MunitParameter params[],
    void* fixture);
static MunitResult test_init_segment_undef_ack(const MunitParameter params[],
    void* fixture);
static MunitResult test_init_segment_withvals(const MunitParameter params[],
    void* fixture);
static MunitResult test_init_segment_payonly(const MunitParameter params[],    
    void* fixture);
    
static MunitResult test_set_udp_socket(const MunitParameter params[], 
    void* fixture);
static MunitResult test_set_udp_socket_err(const MunitParameter params[], 
    void* fixture);
    
static MunitResult test_set_socket_timeout(const MunitParameter params[], 
    void* fixture);

static MunitResult test_read_data(const MunitParameter params[], 
    void* fixture);

static MunitResult test_send_metadata(const MunitParameter params[], 
    void* fixture);

static MunitResult test_send_data(const MunitParameter params[], 
    void* fixture);

static MunitTest tests[] = {
    { "/test_init_protocol", test_init_protocol, NULL, NULL, 
        MUNIT_TEST_OPTION_NONE, NULL },

    { "/test_init_segment_undef_data", test_init_segment_undef_data, NULL, NULL, 
        MUNIT_TEST_OPTION_NONE, NULL },
    { "/test_init_segment_undef_ack", test_init_segment_undef_ack, NULL, NULL, 
        MUNIT_TEST_OPTION_NONE, NULL },
    { "/test_init_segment_withvals", test_init_segment_withvals, NULL, NULL, 
        MUNIT_TEST_OPTION_NONE, NULL },
    { "/test_init_segment_payonly", test_init_segment_payonly, NULL, NULL, 
        MUNIT_TEST_OPTION_NONE, NULL },

    { "/test_set_udp_socket", test_set_udp_socket, NULL, NULL, 
        MUNIT_TEST_OPTION_NONE, NULL },
    { "/test_set_udp_socket_err", test_set_udp_socket_err, NULL, NULL, 
        MUNIT_TEST_OPTION_NONE, NULL },
        
    { "/test_set_socket_timeout", test_set_socket_timeout, NULL, NULL, 
        MUNIT_TEST_OPTION_NONE, NULL },

    { "/test_read_data", test_read_data, NULL, NULL, 
        MUNIT_TEST_OPTION_NONE, NULL },

    { "/test_send_metadata", test_send_metadata, NULL, NULL, 
        MUNIT_TEST_OPTION_NONE, NULL },
    { "/test_send_data", test_send_data, NULL, NULL, 
        MUNIT_TEST_OPTION_NONE, NULL },

    { NULL, NULL, NULL, NULL, MUNIT_TEST_OPTION_NONE, NULL},
};

static const MunitSuite suite = {
    "/test_rft_client_util", tests, NULL, 1, MUNIT_SUITE_OPTION_NONE 
};    


int main(int argc, char** argv) {
    return munit_suite_main(&suite, NULL, argc, argv);
}

static void set_segment_values(segment_t* seg, seg_type type, int i) {
    seg->type = type;
    seg->sq = i;
    seg->checksum = i * i;
    seg->file_data =  i * i * i;

    for (int j = 0; j < PAYLOAD_SIZE; j++)
        seg->payload[j] = i + j;
}

static bool verify_segment_values(segment_t* seg, seg_type type, int i) {
    return seg->type == type && seg->sq == i && seg->checksum == i * i 
            && seg->file_data == i * i * i; 
}

static bool segment_is_init(segment_t* seg, seg_type type) {
    bool is_init = true;
    
    for (int i = 0; i < PAYLOAD_SIZE; i++)
        is_init = is_init && !seg->payload[i];
    
    return  is_init && !seg->sq && seg->type == type
                && !seg->checksum && !seg->file_data;
}

static MunitResult test_init_protocol(const MunitParameter params[], 
    void* fixture) {
    protocol_t proto;
    
    init_protocol(&proto);
    
    assert_int(proto.state, ==, PS_INIT);
    assert_null(proto.err_msg);
    assert_null(proto.src_file);
    assert_int(proto.src_line, ==, 0);
    
    for (int i = 0; i < MAX_FILENAME_SIZE; i++) {
        assert_int(proto.in_fname[i], ==, 0);
        assert_int(proto.out_fname[i], ==, 0);
        assert_int(proto.server_addr[i], ==, 0);
    }
    
    assert_int(proto.server_port, ==, 0);
    assert_int(proto.timeout_sec, ==, DEFAULT_TIMEOUT);
    assert_null(proto.in_file);
    assert_llong((long long) proto.fsize, ==, 0);
    assert_int(proto.sockfd, ==, -1);
    
    char* server_ptr = (char*) &proto.server;
    for (int i = 0; i < sizeof(struct sockaddr_in); i++)
        assert_char(server_ptr[i], ==, 0);
    
    assert_llong((long long) proto.seg_size, ==, sizeof(segment_t));
    assert_llong((long long) proto.sockaddr_size, ==, 
        sizeof(struct sockaddr_in));
    
    assert_true(segment_is_init(&proto.data, DATA_SEG));

    assert_true(segment_is_init(&proto.ack, ACK_SEG));

    assert_null(proto.tfr_mode);
    assert_null(proto.send_file_op);
    assert_float(proto.loss_prob, ==, 0.0);
    assert_true(fpclassify(proto.loss_prob) == FP_ZERO);
    assert_llong((long long) proto.tfr_bytes, == ,0);
    assert_llong((long long) proto.total_file_data, ==, 0);
    assert_int(proto.total_segments, ==, 0);
    assert_int(proto.resent_segments, ==, 0);
    
    return MUNIT_OK;
}

static MunitResult test_init_segment_undef_data(const MunitParameter params[], 
    void* fixture) {
    protocol_t proto;
    proto.seg_size = sizeof(segment_t);

    proto.ack.sq = 1;
    init_segment(&proto, DATA_SEG, false);
    assert_true(segment_is_init(&proto.data, DATA_SEG));
    assert_false(segment_is_init(&proto.ack, ACK_SEG));
    assert_int(proto.ack.sq, ==, 1);

    return MUNIT_OK;
}

static MunitResult test_init_segment_undef_ack(const MunitParameter params[], 
    void* fixture) {
    protocol_t proto;
    proto.seg_size = sizeof(segment_t);

    proto.data.sq = 1;
    init_segment(&proto, ACK_SEG, false);
    assert_true(segment_is_init(&proto.ack, ACK_SEG));
    assert_false(segment_is_init(&proto.data, DATA_SEG));
    assert_int(proto.data.sq, ==, 1);

    return MUNIT_OK;
}

static MunitResult test_init_segment_withvals(const MunitParameter params[],    
    void* fixture) {
    protocol_t proto;
    proto.seg_size = sizeof(segment_t);

    for (int i = 0; i < 10; i++) {
        set_segment_values(&proto.data, DATA_SEG, i);
        set_segment_values(&proto.ack, ACK_SEG, i);  
              
        assert_true(verify_segment_values(&proto.data, DATA_SEG, i));
        assert_true(verify_segment_values(&proto.ack, ACK_SEG, i));
        for (int j = 0; j < PAYLOAD_SIZE; j++) {
            assert_int(proto.data.payload[j], ==, i + j);
            assert_int(proto.ack.payload[j], ==, i + j);
        }
        
        init_segment(&proto, DATA_SEG, false);

        assert_true(segment_is_init(&proto.data, DATA_SEG));

        assert_false(segment_is_init(&proto.ack, ACK_SEG));
        assert_true(verify_segment_values(&proto.ack, ACK_SEG, i));
        for (int j = 0; j < PAYLOAD_SIZE; j++) {
            assert_int(proto.ack.payload[j], ==, i + j);
        }
    }

    for (int i = 0; i < 10; i++) {
        set_segment_values(&proto.data, DATA_SEG, i + 1);
        set_segment_values(&proto.ack, ACK_SEG, i + 1);  
              
        assert_true(verify_segment_values(&proto.data, DATA_SEG, i + 1));
        assert_true(verify_segment_values(&proto.ack, ACK_SEG, i + 1));
        for (int j = 0; j < PAYLOAD_SIZE; j++) {
            assert_int(proto.data.payload[j], ==, i + 1 + j);
            assert_int(proto.ack.payload[j], ==, i + 1 + j);
        }
        
        init_segment(&proto, ACK_SEG, false);

        assert_true(segment_is_init(&proto.ack, ACK_SEG));

        assert_false(segment_is_init(&proto.data, DATA_SEG));
        assert_true(verify_segment_values(&proto.data, DATA_SEG, i + 1));
        for (int j = 0; j < PAYLOAD_SIZE; j++) {
            assert_int(proto.data.payload[j], ==, i + 1 + j);
        }
    }

    return MUNIT_OK;
}
    
static MunitResult test_init_segment_payonly(const MunitParameter params[], 
    void* fixture) {
    protocol_t proto;
    proto.seg_size = sizeof(segment_t);

    for (int i = 0; i < 10; i++) {
        set_segment_values(&proto.data, DATA_SEG, i);        
        set_segment_values(&proto.ack, ACK_SEG, i);        
        assert_true(verify_segment_values(&proto.data, DATA_SEG, i));
        assert_true(verify_segment_values(&proto.ack, ACK_SEG, i));
        for (int j = 0; j < PAYLOAD_SIZE; j++) {
            assert_int(proto.data.payload[j], ==, i + j);
            assert_int(proto.ack.payload[j], ==, i + j);
        }
        
        init_segment(&proto, DATA_SEG, true);
        
        assert_true(verify_segment_values(&proto.data, DATA_SEG, i));
        assert_true(verify_segment_values(&proto.ack, ACK_SEG, i));
        for (int j = 0; j < PAYLOAD_SIZE; j++) {
            assert_int(proto.data.payload[j], ==, 0);
            assert_int(proto.ack.payload[j], ==, i + j);
        }
    }
        
    for (int i = 0; i < 10; i++) {
        set_segment_values(&proto.data, DATA_SEG, i + 1);        
        set_segment_values(&proto.ack, ACK_SEG, i + 1);        
        assert_true(verify_segment_values(&proto.data, DATA_SEG, i + 1));
        assert_true(verify_segment_values(&proto.ack, ACK_SEG, i + 1));
        for (int j = 0; j < PAYLOAD_SIZE; j++) {
            assert_int(proto.data.payload[j], ==, i + 1 + j);
            assert_int(proto.ack.payload[j], ==, i + 1 + j);
        }
        
        init_segment(&proto, ACK_SEG, true);
        
        assert_true(verify_segment_values(&proto.data, DATA_SEG, i + 1));
        assert_true(verify_segment_values(&proto.ack, ACK_SEG, i + 1));
        for (int j = 0; j < PAYLOAD_SIZE; j++) {
            assert_int(proto.data.payload[j], ==, i + 1 + j);
            assert_int(proto.ack.payload[j], ==, 0);
        }
    }
    
    return MUNIT_OK;
}

static MunitResult test_set_udp_socket(const MunitParameter params[], 
    void* fixture) {
    char* server_addr;
    protocol_t proto;
    
    proto.state = PS_INIT;
    proto.sockfd = -1;
    server_addr = "127.0.0.1";
    
    snprintf(proto.server_addr, MAX_FILENAME_SIZE, "%s", server_addr);
    assert_string_equal(proto.server_addr, server_addr);
        
    set_udp_socket(&proto);
    
    assert_int(proto.state, ==, PS_TFR_READY);
    assert_int(proto.sockfd, !=, -1);
    close(proto.sockfd);

    proto.state = PS_INIT;
    proto.sockfd = -1;
    server_addr = "128.240.212.56";
    
    snprintf(proto.server_addr, MAX_FILENAME_SIZE, "%s", server_addr);
    assert_string_equal(proto.server_addr, server_addr);
        
    set_udp_socket(&proto);
    
    assert_int(proto.state, ==, PS_TFR_READY);
    assert_int(proto.sockfd, !=, -1);
    close(proto.sockfd);
 
    proto.state = PS_INIT;
    proto.sockfd = -1;
    server_addr = "128";
    
    snprintf(proto.server_addr, MAX_FILENAME_SIZE, "%s", server_addr);
    assert_string_equal(proto.server_addr, server_addr);
        
    set_udp_socket(&proto);
    
    assert_int(proto.state, ==, PS_TFR_READY);
    assert_int(proto.sockfd, !=, -1);
    close(proto.sockfd);

    return MUNIT_OK;
}

static MunitResult test_set_udp_socket_err(const MunitParameter params[], 
    void* fixture) {
    char* server_addr;
    protocol_t proto;
    
    proto.state = PS_INIT;
    proto.sockfd = -1;
    memset(proto.server_addr, 0, MAX_FILENAME_SIZE);
        
    set_udp_socket(&proto);
    
    assert_int(proto.state, ==, PS_INIT);
    assert_int(proto.sockfd, ==, -1);
    
    server_addr = "cs-linux.ncl.ac.uk";
    snprintf(proto.server_addr, MAX_FILENAME_SIZE, "%s", server_addr);
    assert_string_equal(proto.server_addr, server_addr);
    set_udp_socket(&proto);
    
    assert_int(proto.state, ==, PS_INIT);
    assert_int(proto.sockfd, ==, -1);

    server_addr = "invalid_addr";
    snprintf(proto.server_addr, MAX_FILENAME_SIZE, "%s", server_addr);
    assert_string_equal(proto.server_addr, server_addr);
    set_udp_socket(&proto);
    
    assert_int(proto.state, ==, PS_INIT);
    assert_int(proto.sockfd, ==, -1);

    return MUNIT_OK;
}

static MunitResult test_set_socket_timeout(const MunitParameter params[], 
    void* fixture) {    
    protocol_t proto;
    struct timeval timeout;
    socklen_t to_size = sizeof(struct timeval);     
    timeout.tv_sec = 0;
    timeout.tv_usec = 0;

    memset(&proto, 0, sizeof(protocol_t));
    proto.sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    proto.timeout_sec = DEFAULT_TIMEOUT;
    
    set_socket_timeout(&proto);
    
    getsockopt(proto.sockfd, SOL_SOCKET, SO_RCVTIMEO, &timeout, &to_size);
    
    close(proto.sockfd);
    
    assert_int(timeout.tv_sec, ==, DEFAULT_TIMEOUT);
    assert_int(timeout.tv_usec, ==, 0);
    assert_ulong(to_size, ==, sizeof(struct timeval));

    return MUNIT_OK;
}

static MunitResult test_read_data(const MunitParameter params[], 
    void* fixture) {
    /* check what does on bad read */
    protocol_t proto;
    
    FILE* f = fopen("in34.txt", "r");
    
    assert_not_null(f);
    
    proto.in_file = f;
    proto.tfr_bytes = 34;
    
    read_data(&proto);
    
    assert_int(proto.tfr_bytes, ==, 0);
    assert_int(proto.data.file_data, ==, 34);
    assert_int(proto.data.payload[PAYLOAD_SIZE-1], ==, 0);
    assert_int(strnlen(proto.data.payload, PAYLOAD_SIZE), ==, 34);
    assert_string_equal(proto.data.payload, 
        "hello\ngoodbye\ntest 34 char payload");
    
    fclose(f);

    f = fopen("in35.txt", "r");
    
    assert_not_null(f);
    
    proto.in_file = f;
    proto.tfr_bytes = 35;
    
    read_data(&proto);
    
    assert_int(proto.tfr_bytes, ==, 0);
    assert_int(proto.data.file_data, ==, 35);
    assert_int(proto.data.payload[PAYLOAD_SIZE-1], ==, 0);
    assert_int(strnlen(proto.data.payload, PAYLOAD_SIZE), ==, 35);
    assert_string_equal(proto.data.payload, 
        "hello\ngoodbye\ntest 35 char payload\n");
    
    fclose(f);

    f = fopen("in36.txt", "r");
    
    assert_not_null(f);
    
    proto.in_file = f;
    proto.tfr_bytes = 36;
    
    read_data(&proto);
    
    assert_int(proto.tfr_bytes, ==, 1);
    assert_int(proto.data.file_data, ==, 35);
    assert_int(proto.data.payload[PAYLOAD_SIZE-1], ==, 0);
    assert_int(strnlen(proto.data.payload, PAYLOAD_SIZE), ==, 35);
    assert_string_equal(proto.data.payload, 
        "hello goodbye test 36 char payload!");
    
    read_data(&proto);
    
    assert_int(proto.tfr_bytes, ==, 0);
    assert_int(proto.data.file_data, ==, 1);
    
    assert_string_equal(proto.data.payload,  "!");
    fclose(f);
    
    f = fopen("in350.txt", "r");
    assert_not_null(f);
    
    proto.in_file = f;
    proto.tfr_bytes = 350;
        
    for (int i = 0; i < 10; i++) {
        read_data(&proto);
        assert_int(proto.tfr_bytes, ==, 350 - ((i + 1) * 35));
        assert_int(proto.data.file_data, ==, 35);
        assert_int(proto.data.payload[PAYLOAD_SIZE-1], ==, 0);
        assert_int(strnlen(proto.data.payload, PAYLOAD_SIZE), ==, 35);
    }
    
    fclose(f);   

    f = fopen("in660.txt", "r");
    assert_not_null(f);
    
    proto.in_file = f;
    proto.tfr_bytes = 660;
        
    for (int i = 0; i < 18; i++) {
        read_data(&proto);
        assert_int(proto.tfr_bytes, ==, 660 - ((i + 1) * 35));
        assert_int(proto.data.file_data, ==, 35);
        assert_int(proto.data.payload[PAYLOAD_SIZE-1], ==, 0);
        assert_int(strnlen(proto.data.payload, PAYLOAD_SIZE), ==, 35);
    }
    
    read_data(&proto);
    assert_int(proto.tfr_bytes, ==, 0);
    assert_int(proto.data.file_data, ==, 30);
    assert_int(proto.data.payload[PAYLOAD_SIZE-1], ==, 0);
    assert_int(strnlen(proto.data.payload, PAYLOAD_SIZE), ==, 30);
    fclose(f);   

    return MUNIT_OK;
}

void test_client_err(int sockfd, pid_t ppid, char* err_msg, int line) {
    if (sockfd != -1)
        close(sockfd);
    kill(ppid, SIGKILL);
    munit_errorf("client error: %s at line: %d", err_msg, line);
    exit(EXIT_FAILURE);
}

static MunitResult test_send_metadata(const MunitParameter params[], 
    void* fixture) {
    pid_t ppid = getpid();
    pid_t pid = fork();
    
    assert_int(pid, !=, -1);
        
    if (pid == 0) {
        sleep(1);

        protocol_t proto;
        memset(&proto, 0, sizeof(protocol_t));
        proto.sockaddr_size = (socklen_t) sizeof(struct sockaddr_in); 
        proto.fsize = 64;
        snprintf(proto.out_fname, MAX_FILENAME_SIZE, "%s", "test_file.txt");
        
        proto.sockfd = socket(AF_INET, SOCK_DGRAM, 0);
        if (proto.sockfd == -1) {
            test_client_err(proto.sockfd, ppid, "socket failed", __LINE__ - 2);
        }
            
        proto.server.sin_family = AF_INET;
        proto.server.sin_port = htons(TEST_PORT);
        if(!inet_aton("127.0.0.1", &proto.server.sin_addr)) {
            test_client_err(proto.sockfd, ppid, "inet_aton failed", 
                __LINE__ - 2);
        }
        
        if (!send_metadata(&proto)) {
            test_client_err(proto.sockfd, ppid, "send_metadata failed", 
                __LINE__ - 2);
        }
        
        close(proto.sockfd);

        exit(EXIT_SUCCESS);
    } else {
        // in parent
        int child_stat;
        
        metadata_t file_inf;
        size_t metadata_size = sizeof(metadata_t);
        memset(&file_inf, 0, sizeof(metadata_t));
        socklen_t sock_len = (socklen_t) sizeof(struct sockaddr_in); ;
        ssize_t bytes = -1;

        int sockfd = socket(AF_INET, SOCK_DGRAM, 0);
        assert_int(sockfd, !=, -1);
        struct sockaddr_in server;

        server.sin_family = AF_INET;
        server.sin_addr.s_addr = htonl(INADDR_ANY);
        server.sin_port = htons(TEST_PORT);
 
        if (bind(sockfd, (struct sockaddr *) &server, sock_len)) {
            munit_errorf("bind failed, try setting TEST_PORT to a different "
                "value at line %d (TEST_PORT is currently set to: %d)", 
                TEST_PORT_ERR_LINE, TEST_PORT); 
            close(sockfd);
            exit(EXIT_FAILURE);
        }

        struct sockaddr_in client;
        memset(&client, 0, sock_len);
    
        bytes = recvfrom(sockfd, &file_inf, metadata_size, 0, 
                        (struct sockaddr*) &client, &sock_len);
        
        assert_int(bytes, ==, metadata_size);
        assert_string_equal(file_inf.name, "test_file.txt");
        assert_int(file_inf.size, ==, 64);

        waitpid(pid, &child_stat, 0);
        assert_int(WEXITSTATUS(child_stat), ==, EXIT_SUCCESS);
        close(sockfd);

        munit_log(MUNIT_LOG_INFO, "Metadata received successfully");
    }

    return MUNIT_OK;
}

static MunitResult test_send_data(const MunitParameter params[], 
    void* fixture) {   
    char* data[] = { "a", "abc", "abcdefghijklmnopqrstuvwxyz012345678" };
    int data_len[] = { 1, 3, 35 };
    pid_t ppid = getpid();
    pid_t pid = fork();
    
    if (pid < -1)
        return MUNIT_FAIL;

    if (pid == 0) {
        // in child
        sleep(1);
        
        protocol_t proto;
        memset(&proto, 0, sizeof(protocol_t));
        proto.tfr_mode = "nm";
        proto.sockaddr_size = (socklen_t) sizeof(struct sockaddr_in);
        proto.seg_size = sizeof(segment_t);
        proto.curr_retry = 0;
        proto.max_retries = DEFAULT_RETRIES;
        proto.src_file = __FILE__;

        proto.sockfd = socket(AF_INET, SOCK_DGRAM, 0);
        if (proto.sockfd == -1) {
            test_client_err(proto.sockfd, ppid, "socket failed", __LINE__ - 2);
        }
            
        proto.server.sin_family = AF_INET;
        proto.server.sin_port = htons(TEST_PORT);
        if(!inet_aton("127.0.0.1", &proto.server.sin_addr)) {
            test_client_err(proto.sockfd, ppid, "inet_aton failed", 
                __LINE__ - 2);
        }
        
        proto.state = PS_DATA_SEND;
        
        char ack[3];
        for (int i = 0; i < 3; i++) {
            proto.data.sq = i;
            proto.data.file_data = data_len[i];
            memset(&proto.data.payload, 0, PAYLOAD_SIZE);
            snprintf(proto.data.payload, PAYLOAD_SIZE, "%s", data[i]);
            
            printf("\n");
            send_data(&proto);
        
            socklen_t server_size = proto.sockaddr_size;
            struct sockaddr_in server;
            memset(&server, 0, server_size);
            memset(ack, 0, 3);
            ssize_t nbytes = recvfrom(proto.sockfd, ack, 3,
                0, (struct sockaddr *) &server, &server_size);
                
            if (nbytes != 3) {
                test_client_err(proto.sockfd, ppid, 
                    "recvfrom return nbytes != 3", __LINE__ - 5);
            }
            
            if (strncmp(ack, "OK", 4)) {
                test_client_err(proto.sockfd, ppid, 
                    "recvfrom got server ack != \"OK\"", __LINE__ - 10);
            }
        }
        
        close(proto.sockfd);

        exit(EXIT_SUCCESS);
    } else {
        // in parent
        int child_stat;
        
        int sockfd = socket(AF_INET, SOCK_DGRAM, 0);
        assert_int(sockfd, !=, -1);
        struct sockaddr_in server;

        server.sin_family = AF_INET;
        server.sin_addr.s_addr = htonl(INADDR_ANY);
        server.sin_port = htons(TEST_PORT);
 
        if (bind(sockfd, (struct sockaddr *) &server, 
                    sizeof(struct sockaddr_in))) {
            munit_errorf("bind failed, try setting TEST_PORT to a different "
                "value at line %d (TEST_PORT is currently set to: %d)", 
                TEST_PORT_ERR_LINE, TEST_PORT); 
            close(sockfd);
            exit(EXIT_FAILURE);
        }

        for (int i = 0; i < 3; i++) {
            struct sockaddr_in client;
            socklen_t sock_len = (socklen_t) sizeof(struct sockaddr_in);
            memset(&client, 0, sock_len);
            segment_t data_seg;
            size_t seg_size = sizeof(segment_t);
            memset(&data_seg, 0, seg_size);
    
            ssize_t bytes = recvfrom(sockfd, &data_seg, seg_size, 0, 
                        (struct sockaddr*) &client, &sock_len);
        
            assert_true(bytes == seg_size);
            assert_int(data_seg.payload[PAYLOAD_SIZE-1], ==, 0);
            assert_int(
                strnlen(data_seg.payload, PAYLOAD_SIZE), ==, data_len[i]);
            assert_int(data_seg.file_data, ==, data_len[i]);
            assert_string_equal(data_seg.payload, data[i]);
            assert_int(data_seg.sq, ==, i);
            
            int cs = checksum(data_seg.payload, false);
            assert_int(data_seg.checksum, ==, cs);
                
            printf("server received checksum: %d, sq: %d, bytes: %d\n", 
                cs, data_seg.sq, (int) data_seg.file_data);
            printf("server payload received: %s\n", data_seg.payload);
            
            bytes = sendto(sockfd, "OK", 3, 0, (struct sockaddr*) &client,
                sock_len);
            
            assert_int(bytes, ==, 3);

        }

        waitpid(pid, &child_stat, 0);
        assert_int(WEXITSTATUS(child_stat), ==, EXIT_SUCCESS);
        close(sockfd);
    }

    return MUNIT_OK;
}
